#' Plot a \code{FEM} object
#'
#' @param x A \code{FEM} object.
#' @param colormap A colormap exploited in the plot. The default value is the heat colormap. 
#' @param num_refinements A natural number specifying how many bisections should be applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' This parameter can be specified only when a FEM object defined over a 2D mesh is plotted.
#' @param ... Arguments representing graphical options to be passed to \link[rgl]{plot3d}.
#' @description Three-dimensional plot of a \code{FEM} object, generated by \code{FEM} or returned by
#' \code{smooth.FEM} or \code{FPCA.FEM}.
#' If the \code{mesh} of the \code{FEMbasis} component is of class \code{mesh.2D} both the 3rd axis and the color represent
#' the value of the coefficients for the Finite Element basis expansion (\code{coeff} component of the \code{FEM} object).
#' If the \code{mesh} is of class \code{mesh.3D}, the color of each triangle or tetrahedron represent the mean value of
#' the coefficients for the Finite Element basis expansion (\code{coeff}).
#' @usage \method{plot}{FEM}(x, colormap = "heat.colors", num_refinements = NULL, ...)
#' @export
#' @seealso \code{\link{FEM}}, \code{\link{image.FEM}}
#' @return No return value
#' @examples
#' library(fdaPDE)
#' ## Upload the horseshoe2D data
#' data(horseshoe2D)
#' boundary_nodes = horseshoe2D$boundary_nodes
#' boundary_segments = horseshoe2D$boundary_segments
#' locations = horseshoe2D$locations
#'
#' ## Create the 2D mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#' ## Create the FEM basis
#' FEMbasis = create.FEM.basis(mesh)
#' ## Compute the coeff vector evaluating the desired function at the mesh nodes
#' ## In this case we consider the fs.test() function introduced by Wood et al. 2008
#' coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2])
#' ## Create the FEM object
#' FEMfunction = FEM(coeff, FEMbasis)
#'
#' ## Plot the FEM function
#' plot(FEMfunction)

plot.FEM = function(x, r = NULL, num_refinements = NULL, ...){
  if(is(x$FEMbasis$mesh, "mesh.2D")){
    if(x$FEMbasis$order == 1)
    {
      R_plot.ORD1.FEM(x, r, ...)
    }else{
      R_plot.ORDN.FEM(x, num_refinements, ...)
    }
  }else if(is(x$FEMbasis$mesh, "mesh.2.5D")){
    R_plot_manifold(x,...)
  }else if(is(x$FEMbasis$mesh, "mesh.3D")){
    R_plot_volume_slices(x,...)
  }else if(is(x$FEMbasis$mesh, "mesh.1.5D")){
    R_plot_graph(x, ...)
  }
}

R_plot.ORD1.FEM = function(FEM, r = NULL, ...){
  if(is.null(r)){
    nodes <- FEM$FEMbasis$mesh$nodes
    triangles <- as.vector(t(FEM$FEMbasis$mesh$triangles))
    
    nplots <- ncol(FEM$coeff)
    for (i in 1:nplots) {
      if (i > 1)
        readline("Press any key for the next plot...")
      p <- plot_ly(type = 'mesh3d',
                   
                   x = FEM$FEMbasis$mesh$nodes[,1],
                   y = FEM$FEMbasis$mesh$nodes[,2],
                   z = FEM$coeff[,i],
                   
                   i = FEM$FEMbasis$mesh$triangles[,1]-1,
                   j = FEM$FEMbasis$mesh$triangles[,2]-1,
                   k = FEM$FEMbasis$mesh$triangles[,3]-1, 
                   
                   intensity = FEM$coeff[,i],
                   color = FEM$coeff[,i],
                   ...
      ) %>%
        layout(
          camera = list(
            eye = list(x = 1.25, 
                       y = -1.25, 
                       z = 1.25))
        ) %>%
        colorbar(len = 1)
      print(p)
    }
  }
  else{
    R_plot.map.FEM(FEM, r)
  }
    
}

R_plot.ORDN.FEM = function(FEM, ...){
  # num_refinements sets the number od division on each triangle edge to be applied for rifenment
  coeff = FEM$coeff
  
  FEMbasis = FEM$FEMbasis
  
  mesh = FEMbasis$mesh
  
  if(is.null(num_refinements))
  {
    num_refinements = 10
  }
  
  # For the reference triangles we construct a regular mesh
  x = seq(from = 0, to = 1, length.out = num_refinements+1)
  y = seq(from = 0, to = 1, length.out = num_refinements+1)
  points_ref = expand.grid(x,y)
  points_ref = points_ref[points_ref[,1] + points_ref[,2] <= 1,]
  
  
  meshi = create.mesh.2D(nodes = points_ref, order = 1)
  # plot(meshi)
  
  # locations is the matrix with that will contain the coordinate of the points where the function is
  # evaluated (1st and 2nd column) and the columns with the evaluation of the ith fucntion on that point
  
  locations = matrix(nrow = nrow(mesh$triangles)*nrow(meshi$nodes), ncol = 2+ncol(coeff))
  triangles = matrix(nrow = nrow(mesh$triangles)*nrow(meshi$triangles), ncol = 3)
  tot = 0
  
  properties<-R_elementProperties(mesh)
  
  for (i in 1:nrow(mesh$triangles))
  {
    # For each traingle we define a fine mesh as the transofrmation of the one constructed for the reference
    transf<-rbind(cbind(properties$transf_coord$diff1x[i],properties$transf_coord$diff2x[i]),c(properties$transf_coord$diff1y[i],properties$transf_coord$diff2y[i]))
    pointsi = t(transf%*%t(meshi$nodes) + mesh$nodes[mesh$triangles[i,1],])
    #We evaluate the fine mesh OBS: we know the triangle we are working on no need for point location
    z = R_eval_local.FEM(FEM, transf=properties, locations = pointsi, element_index = i)
    
    #We store the results
    locations[((i-1)*nrow(pointsi)+1):(i*nrow(pointsi)),] = cbind(pointsi,z)
    triangles[((i-1)*nrow(meshi$triangles)+1):(i*nrow(meshi$triangles)),] = meshi$triangles+tot
    tot = tot + nrow(meshi$nodes)
  }
  
  nsurf = dim(coeff)[[2]]
  for (i in 1:nsurf) {
    if (i > 1)
      readline("Press any key for the next plot...")
    p <- plot_ly(type = 'mesh3d', 
                 x = locations[,1], 
                 y = locations[,2], 
                 z = locations[,2+i], 
                 i = triangles[,1]-1, 
                 j = triangles[,2]-1, 
                 k = triangles[,3]-1, 
                 intensity = locations[,2+i], 
                 color = locations[,2+i], 
                 ...
    ) %>%
      colorbar(len = 1)
    print(p)
  }
}

R_plot.map.FEM <- function(FEM, border = TRUE, borderColor = 'black', borderWeight = 2, 
                           grid.length = 500,  opacity = .8, provider = "CartoDB.Positron", ...){
  # Create grid 
  x.min <- min(FEM$FEMbasis$mesh$nodes[,1])
  x.max <- max(FEM$FEMbasis$mesh$nodes[,1])
  y.min <- min(FEM$FEMbasis$mesh$nodes[,2])
  y.max <- max(FEM$FEMbasis$mesh$nodes[,2])
  
  # Creo griglia 
  x <- seq(x.min, x.max, length.out = grid.length)
  y <- seq(y.min, y.max, length.out = grid.length)
  grid <- data.frame(expand.grid(x, y))
  
  # Evaluate FEM on grid points and rasterize
  f_hat <- eval.FEM(FEM, locations = grid)
  grid$f_hat <- f_hat[,1]
  
  # Creo raster
  r_f_hat <- rasterFromXYZ(grid)
  crs(r_f_hat) <- crs('+proj=longlat +datum=WGS84')
  
  # Create palette
  pal <- colorNumeric("viridis", 
                      c(min(na.omit(grid)[,3]), max(na.omit(grid)[,3])), 
                      na.color = "transparent")
  
  # Plot 
  map <- leaflet() %>%
    addProviderTiles(provider) %>%
    addRasterImage(r_f_hat, colors = pal, opacity = opacity) %>%
    addLegend(title = "f", #expression
              pal = pal,
              opacity = opacity,
              values = values(r_f_hat), 
              labFormat = labelFormat(transform = function(x) sort(x, decreasing = TRUE))) %>%
    addScaleBar(position = c("bottomleft"))
  
  if(!border)
    print(map)
  else{
    mesh <- FEM$FEMbasis$mesh
    for (i in 1:nrow(mesh$segments)) {
      map <- map %>%
        addPolylines(lng = mesh$nodes[mesh$segments[i,],1], 
                     lat = mesh$nodes[mesh$segments[i,],2], 
                     color = borderColor, 
                     weight = borderWeight, 
                     opacity = 1
        )
    }
    print(map)
  }
  
  
  
}


R_plot_manifold = function(FEM, ...){
  nodes <- FEM$FEMbasis$mesh$nodes
  triangles <- as.vector(t(FEM$FEMbasis$mesh$triangles))
  coeff <- FEM$coeff
  
  nplots <- ncol(coeff)
  
  for (i in 1:nplots){
    if (i > 1)
      readline("Press any key for the next plot...")
    p <- plot_ly(type = 'mesh3d',
                 
                 x = FEM$FEMbasis$mesh$nodes[,1],
                 y = FEM$FEMbasis$mesh$nodes[,2],
                 z = FEM$FEMbasis$mesh$nodes[,3],
                 
                 i = FEM$FEMbasis$mesh$triangles[,1]-1,
                 j = FEM$FEMbasis$mesh$triangles[,2]-1,
                 k = FEM$FEMbasis$mesh$triangles[,3]-1, 
                 
                 intensity = FEM$coeff[,i],
                 color = FEM$coeff[,i],
                 contour = list(show = T, width = 1, color = 'black'),
                 hoverinfo = 'text',
                 
                 text = paste('</br><b> Coordinates:', round(FEM$FEMbasis$mesh$nodes[,1],2),
                              round(FEM$FEMbasis$mesh$nodes[,2],2),
                              round(FEM$FEMbasis$mesh$nodes[,3],2),
                              '</br><b> Value:', round(FEM$coeff[,i],2)),
                 ...) %>%
      colorbar(len = 1) %>%
      layout(scene = list(
        aspectmode = 'cube', 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )))
    
    # Dispay figure
    print(p)

  }
}

R_plot_volume = function(FEM, ...){
  
  # Number of plots
  coeff <- FEM$coeff
  nplots <- ncol(coeff)
  
  for (i in 1:nplots){
    if (i > 1)
      readline("Press any key for the next plot...")
    p <-   plot_ly(type = 'mesh3d', 
                   x = FEM$FEMbasis$mesh$nodes[,1], 
                   y = FEM$FEMbasis$mesh$nodes[,2], 
                   z = FEM$FEMbasis$mesh$nodes[,3], 
                   i = FEM$FEMbasis$mesh$faces[,1]-1,
                   j = FEM$FEMbasis$mesh$faces[,2]-1,
                   k = FEM$FEMbasis$mesh$faces[,3]-1,
                   intensity = FEM$coeff[,i], 
                   color = FEM$coeff[,i],
                   flatshading = T, 
                   lightposition = list(x = 0, y = 0, z = 0), 
                   ...) %>%
      colorbar(len = 1)%>%
      layout(scene = list(
        aspectmode = 'cube', 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )))
    
    # Dispay figure
    print(p)
  }
}

R_plot_volume_slices = function(FEM, slices = F, no_frames = 20, grid.length = 100, palette = 'Viridis', ...){
  
  if(slices){
    # Mesh coordinates
    x = FEM$FEMbasis$mesh$nodes[,1]
    y = FEM$FEMbasis$mesh$nodes[,2]
    z = FEM$FEMbasis$mesh$nodes[,3]
    
    # Create evaluation grid 
    x.grid = seq(min(x), max(x), length.out = grid.length)
    y.grid = seq(min(y), max(y), length.out = grid.length)
    z.grid = seq(min(z) + diff(range(z))/no_frames, 
                 max(z) - diff(range(z))/no_frames, 
                 length.out = no_frames)
    
    # Evaluate FEM in the grid
    eval.coefs = cbind()
    eval.coefs.list = list()
    mi = Inf
    ma = -Inf
    
    for (z.index in 1:length(z.grid)) {
      eval.coefs = cbind()
      for (j in 1:length(y.grid)){
        eval.coefs = cbind(eval.coefs, eval.FEM(FEM, cbind(x.grid, y.grid[j], z.grid[z.index])))
      }
      eval.coefs.list[[z.index]] = eval.coefs 
      mi = min(mi,  na.omit(c(eval.coefs)))
      ma = max(ma,  na.omit(c(eval.coefs)))
    }
    
    
    ones = matrix(1, nrow = grid.length, ncol = grid.length)
    p <- plot_ly(...)
    steps <- list()
    
    for (i in 1:no_frames) {
      
      # Make the central trace visible
      visible = F
      if(i == as.integer(no_frames/2))
        visible = T
      
      # Figure 
      ones = eval.coefs.list[[i]]/eval.coefs.list[[i]]
      eval.coefs.list[[i]][is.na(eval.coefs.list[[i]])] <- mi - 5*(ma-mi)
      p <- p %>%
        add_trace(type = 'surface', 
                  x = x.grid, 
                  y = y.grid,
                  z = ones*z.grid[i], 
                  surfacecolor = eval.coefs.list[[i]],
                  coloraxis = 'coloraxis', 
                  visible = visible)
      
      step <- list(args = list('visible', rep(FALSE, no_frames)), 
                   label = round(z.grid[i],2),
                   method = 'restyle')
      step$args[[2]][i] = TRUE  
      steps[[i]] = step 
    }
    
    # Set layout
    axx <- list(
      gridcolor='rgb(255, 255, 255)',
      zerolinecolor='rgb(255, 255, 255)',
      showbackground=TRUE,
      backgroundcolor='rgb(230, 230,230)',
      range = list(min(x.grid),max(x.grid)))
    axy <- list(
      gridcolor='rgb(255, 255, 255)',
      zerolinecolor='rgb(255, 255, 255)',
      showbackground=TRUE,
      backgroundcolor='rgb(230, 230,230)',
      range = list(min(y.grid),max(y.grid)))
    axz <- list(
      gridcolor='rgb(255, 255, 255)',
      zerolinecolor='rgb(255, 255, 255)',
      showbackground=TRUE,
      backgroundcolor='rgb(230, 230,230)',
      range = list(min(z.grid)-.01,max(z.grid)))
    
    p <- p %>%
      layout(sliders = list(list(active = as.integer(no_frames/2),
                                 currentvalue = list(prefix = "z = "),
                                 steps = steps)), 
             coloraxis=list(colorscale=palette, 
                            cmin = mi,
                            cmax = ma), 
             scene = list(
               xaxis = axx,
               yaxis = axy,
               zaxis = axz, 
               aspectmode='cube'))
    
    # Display
    print(p) 
  }
  else{
    R_plot_volume(FEM, ...)
  }
  
  
}

plot.FEM.time = function(x, num_refinements = NULL, Nt = NULL, tlim = NULL,  ...){
  if(!is(x, "FEM.time"))
    stop("x is not of class 'FEM.time'")
  if(is(x$FEMbasis$mesh, "mesh.2D")){
    if(x$FEMbasis$order == 1)
    {
      R_plot.ORD1.FEM.time(x, ...)
    }else{
      R_plot.ORDN.FEM.time(x, num_refinements, ...)
    }
  }else if(is(x$FEMbasis$mesh, "mesh.2.5D")){
    R_plot_manifold.time(x,...)
  }else if(is(x$FEMbasis$mesh, "mesh.3D")){
    R_plot_volume.time(x,...)
  }else if(is(x$FEMbasis$mesh, "mesh.1.5D")){
    R_plot_graph.time(x, ...)
  }
}

R_plot.ORD1.time = function(FEM_time, shared_bar = TRUE, ...){
  time <- FEM_time$mesh_time
  time_lenght <- length(FEM_time$mesh_time)
  nplots <- ncol(FEM_time$coeff)
  for(i in 1:nplots){
    if(!shared_bar){
      p <- plot_ly(type = 'mesh3d',
              x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
              y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
              z = FEM_time$coeff[,i],
              i = FEM_time$FEMbasis$mesh$triangles[,1]-1,
              j = FEM_time$FEMbasis$mesh$triangles[,2]-1,
              k = FEM_time$FEMbasis$mesh$triangles[,3]-1,
              frame = sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),
              intensity = FEM_time$coeff[,i],
              color = FEM_time$coeff[,i],
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                           round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                           round(FEM_time$coeff[,i],2),
                           '</br><b> Value:', round(FEM_time$coeff[,i],2)),
              ...) %>%
        colorbar(len = 1) %>%
        layout(scene = list(zaxis = list(
          range = list(min(FEM_time$coeff[,i]),max(FEM_time$coeff[,i]))
        )))
      print(p)
    }
    else{
      p <- plot_ly(type = 'mesh3d',
              x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
              y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
              z = FEM_time$coeff[,i],
              i = FEM_time$FEMbasis$mesh$triangles[,1]-1,
              j = FEM_time$FEMbasis$mesh$triangles[,2]-1,
              k = FEM_time$FEMbasis$mesh$triangles[,3]-1,
              frame = sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),
              intensity = FEM_time$coeff[,i],
              color = FEM_time$coeff[,i],
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                           round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                           round(FEM_time$coeff[,i],2),
                           '</br><b> Value:', round(FEM_time$coeff[,i],2)),
              cmin = min(FEM_time$coeff[,i]),
              cmax = max(FEM_time$coeff[,i]),
              ...) %>%
        colorbar(len = 1) %>%
        layout(scene = list(zaxis = list(
          range = list(min(FEM_time$coeff[,i]),max(FEM_time$coeff[,i]))
        )))
      print(p)
    }
  }
  
  
}

R_plot_manifold.time = function(FEM_time, shared_bar = TRUE, ...){
  
  time <- FEM_time$mesh_time
  time_lenght <- length(FEM_time$mesh_time)
  
  nplots <- ncol(FEM_time$coeff)
  for (i in 1:nplots) {
    if(nplots == 1)
      coeff = FEM_time$coeff[,1,1]
    else
      coeff = FEM_time$coeff[,i]
    if(!shared_bar){
      p <- plot_ly(type = 'mesh3d',
              x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
              y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
              z = rep(FEM_time$FEMbasis$mesh$nodes[,3], time_lenght),
              i = FEM_time$FEMbasis$mesh$triangles[,1]-1,
              j = FEM_time$FEMbasis$mesh$triangles[,2]-1,
              k = FEM_time$FEMbasis$mesh$triangles[,3]-1,
              frame = sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),
              intensity = coeff,
              color = coeff,
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                           round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                           round(FEM_time$FEMbasis$mesh$nodes[,3],2),
                           '</br><b> Value:', round(coeff,2)),
              ...) %>%
        colorbar(len = 1) 
      print(p)
    }
    else{
      p <- plot_ly(type = 'mesh3d',
              x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
              y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
              z = rep(FEM_time$FEMbasis$mesh$nodes[,3], time_lenght),
              i = FEM_time$FEMbasis$mesh$triangles[,1]-1,
              j = FEM_time$FEMbasis$mesh$triangles[,2]-1,
              k = FEM_time$FEMbasis$mesh$triangles[,3]-1,
              frame = sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),
              intensity = coeff,
              color = coeff,
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                           round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                           round(FEM_time$FEMbasis$mesh$nodes[,3],2),
                           '</br><b> Value:', round(coeff,2)),
              cmin = min(coeff),
              cmax = max(coeff),
              ...) %>%
        colorbar(len = 1) 
      print(p)
    }
  }
  
  
}

R_plot_volume.time = function(FEM_time, shared_bar = TRUE, ...){
  
  time <- FEM_time$mesh_time
  time_lenght <- length(FEM_time$mesh_time)
  
  nplots <- ncol(FEM_time$coeff)
  for (i in 1:nplots) {
    if(nplots == 1)
      coeff = FEM_time$coeff[,1,1]
    else
      coeff = FEM_time$coeff[,i]
    if(!shared_bar){
      p <- plot_ly(type = 'mesh3d',
                   x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
                   y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
                   z = rep(FEM_time$FEMbasis$mesh$nodes[,3], time_lenght),
                   i = FEM_time$FEMbasis$mesh$faces[,1]-1,
                   j = FEM_time$FEMbasis$mesh$faces[,2]-1,
                   k = FEM_time$FEMbasis$mesh$faces[,3]-1,
                   frame = sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),
                   intensity = coeff,
                   color = coeff,
                   flatshading = T, 
                   lightposition = list(x = 0, y = 0, z = 0), 
                   hoverinfo = 'text',
                   
                   text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                                round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                                round(FEM_time$FEMbasis$mesh$nodes[,3],2),
                                '</br><b> Value:', round(coeff,2)),
                   ...) %>%
        colorbar(len = 1) 
      print(p)
    }
    else{
      p <- plot_ly(type = 'mesh3d',
                   x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
                   y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
                   z = rep(FEM_time$FEMbasis$mesh$nodes[,3], time_lenght),
                   i = FEM_time$FEMbasis$mesh$faces[,1]-1,
                   j = FEM_time$FEMbasis$mesh$faces[,2]-1,
                   k = FEM_time$FEMbasis$mesh$faces[,3]-1,
                   frame = sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),
                   intensity = coeff,
                   color = coeff,
                   flatshading = T, 
                   lightposition = list(x = 0, y = 0, z = 0), 
                   hoverinfo = 'text',
                   
                   text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                                round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                                round(FEM_time$FEMbasis$mesh$nodes[,3],2),
                                '</br><b> Value:', round(coeff,2)),
                   cmin = min(coeff),
                   cmax = max(coeff),
                   ...) %>%
        colorbar(len = 1) 
      print(p)
    }
  }
  
  
}

plot.FEM.time <- function(FEM.time, Nt = 50, z.view = 2, ...){
  if(!FEM.time$FLAG_PARABOLIC){
    eval_time <- seq(min(FEM.time$mesh_time), max(FEM.time$mesh_time), length.out = Nt)
    
    x <- rep(FEM.time$FEMbasis$mesh$nodes[,1], Nt)
    y <- rep(FEM.time$FEMbasis$mesh$nodes[,2], Nt)
    t <- sort(rep(eval_time, nrow(FEM.time$FEMbasis$mesh$nodes)))
    
    space.time.locations <- cbind(t,x,y)
    
    evaluation <- eval.FEM.time(FEM.time, space.time.locations = space.time.locations)
    
    p <- plot_ly(type = 'mesh3d', 
            x = x, 
            y = y, 
            z = rep(0,length(x)), 
            i = FEM.time$FEMbasis$mesh$triangles[,1]-1,
            j = FEM.time$FEMbasis$mesh$triangles[,2]-1,
            k = FEM.time$FEMbasis$mesh$triangles[,3]-1,
            intensity = evaluation, 
            color = evaluation, 
            frame = round(t,3),
            hoverinfo = 'text',
            text = paste('</br><b> Coordinates:', round(FEM.time$FEMbasis$mesh$nodes[,1],2),
                         round(FEM.time$FEMbasis$mesh$nodes[,2],2),
                         '</br><b> Value:', round(evaluation,2)),
            cmin = min(evaluation),
            cmax = max(evaluation)) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = z.view)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom')  %>%
      animation_slider(
        currentvalue = list(prefix = "Spatial function in t = ")
      ) %>%
      colorbar(len = 1) 
    
  }
  if(FEM.time$FLAG_PARABOLIC){
    time <- FEM.time$mesh_time
    N <- length(time)
    x <- rep(FEM.time$FEMbasis$mesh$nodes[,1], N)
    y <- rep(FEM.time$FEMbasis$mesh$nodes[,2], N)
    t <- sort(rep(time, nrow(FEM.time$FEMbasis$mesh$nodes)))
    
    p <- plot_ly(type = 'mesh3d', 
            x = x, 
            y = y, 
            z = rep(0,length(x)), 
            i = FEM.time$FEMbasis$mesh$triangles[,1]-1,
            j = FEM.time$FEMbasis$mesh$triangles[,2]-1,
            k = FEM.time$FEMbasis$mesh$triangles[,3]-1,
            intensity = FEM.time$coeff, 
            color = FEM.time$coeff, 
            frame = round(t,3),
            hoverinfo = 'text',
            text = paste('</br><b> Coordinates:', round(FEM.time$FEMbasis$mesh$nodes[,1],2),
                         round(FEM.time$FEMbasis$mesh$nodes[,2],2),
                         '</br><b> Value:', round(FEM.time$coeff,2)),
            cmin = min(FEM.time$coeff),
            cmax = max(FEM.time$coeff)) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = z.view)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom')  %>%
      animation_slider(
        currentvalue = list(prefix = "Spatial function in t = ")
      ) %>%
      colorbar(len = 1) 
  }
  p
  
}

plot.FEM.time.interactive <- function(FEM.time, Nt = 50, z.view = 2, ...){
  if(!FEM.time$FLAG_PARABOLIC){
    eval_time <- seq(min(FEM.time$mesh_time), max(FEM.time$mesh_time), length.out = Nt)
    
    x <- rep(FEM.time$FEMbasis$mesh$nodes[,1], Nt)
    y <- rep(FEM.time$FEMbasis$mesh$nodes[,2], Nt)
    id <- rep(1:nrow(FEM.time$FEMbasis$mesh$nodes), Nt)
    t <- sort(rep(eval_time, nrow(FEM.time$FEMbasis$mesh$nodes)))
    
    space.time.locations <- cbind(t,x,y)
    
    evaluation <- eval.FEM.time(FEM.time, space.time.locations = space.time.locations)
    
    df <- data.frame(x = x, y = y, z = 0, id = id, time = t, value = evaluation)
    
    # Select options
    s <- attrs_selected(
      marker = list(opacity = 0, color = 'red', size = 8), 
      line = list(color = 'red', width = 6)
    )
    
    # Graphs
    N <- nrow(FEM.time$FEMbasis$mesh$nodes)
    
    base <- df %>% 
      highlight_key(~id) %>%
      plot_ly()
    
    spatial <- base %>% 
      group_by(id) %>%
      summarise(x = mean(x), y = mean(y), z = mean(z)*0, id = mean(id)) %>%
      add_trace(type = 'mesh3d', 
                x = FEM.time$FEMbasis$mesh$nodes[,1], 
                y = FEM.time$FEMbasis$mesh$nodes[,2], 
                z = rep(0,N),
                i = FEM.time$FEMbasis$mesh$triangles[,1]-1,
                j = FEM.time$FEMbasis$mesh$triangles[,2]-1,
                k = FEM.time$FEMbasis$mesh$triangles[,3]-1, 
                intensity = rep(0,N),
                color = rep(0,N),
                colors = 'lightgrey',
                opacity = .8,
                hoverinfo = "text",
                text = ~paste("Coordinates: (", round(x,2), round(y,2), ")",
                              "<br>Id: ", id)) %>%
      add_trace(type = 'scatter3d', 
                mode = 'markers',
                x = ~x, y = ~y, z=~z, size = .1, color = I('grey'), opacity = .6,
                hoverinfo = "text",
                text = ~paste("")) %>% 
      hide_colorbar() %>%
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = z.view)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ))) 
    
    
    time_series <- base %>%
      group_by(id) %>%
      add_trace(type = 'scatter', mode = 'lines+markers', x = ~time, y = ~value, hoverinfo = 'text', text = ~paste('Time:', time, 
                                                                                                                   '<br>Coeff:', round(value,2), 
                                                                                                                   '<br>Id:', id), 
                opacity = .5, line = list(color = 'grey', width = 1), marker = list(color = 'grey', size = 1)) %>% 
      layout(title = "Time evolution of each mesh node", 
             xaxis = list(
               zerolinecolor = '#ffff',
               nticks=10,
               zerolinecolor = '#ffff',
               zerolinewidth = 4,
               gridcolor = 'ffff',
               ticks="inside"),
             
             yaxis = list(
               nticks=10,
               zerolinecolor = '#ffff',
               zerolinewidth = 4,
               gridcolor = 'ffff',
               ticks="inside"))
    
    
    p <- subplot(time_series, spatial, nrows = 2) %>% 
      hide_legend() %>%
      layout(scene = list(domain=list(x=c(0,1),y=c(0,.5)))) %>%
      highlight(on = "plotly_click", off = "plotly_doubleclick", 
                selectize = TRUE, dynamic = TRUE, persistent = TRUE,
                opacityDim = getOption("opacityDim", 0.4), selected = s)
    
    p
  }
  if(FEM.time$FLAG_PARABOLIC){
    eval_time <- FEM.time$mesh_time
    Nt <- length(eval_time)
    
    x <- rep(FEM.time$FEMbasis$mesh$nodes[,1], Nt)
    y <- rep(FEM.time$FEMbasis$mesh$nodes[,2], Nt)
    id <- rep(1:nrow(FEM.time$FEMbasis$mesh$nodes), Nt)
    t <- sort(rep(eval_time, nrow(FEM.time$FEMbasis$mesh$nodes)))
    
    df <- data.frame(x = x, y = y, z = 0, id = id, time = t, value = FEM.time$coeff)
    
    # Select options
    s <- attrs_selected(
      marker = list(opacity = 0, color = 'red', size = 8), 
      line = list(color = 'red', width = 6)
    )
    
    # Graphs
    N <- nrow(FEM.time$FEMbasis$mesh$nodes)
    
    base <- df %>% 
      highlight_key(~id) %>%
      plot_ly()
    
    spatial <- base %>% 
      group_by(id) %>%
      summarise(x = mean(x), y = mean(y), z = mean(z)*0, id = mean(id)) %>%
      add_trace(type = 'mesh3d', 
                x = FEM.time$FEMbasis$mesh$nodes[,1], 
                y = FEM.time$FEMbasis$mesh$nodes[,2], 
                z = rep(0,N),
                i = FEM.time$FEMbasis$mesh$triangles[,1]-1,
                j = FEM.time$FEMbasis$mesh$triangles[,2]-1,
                k = FEM.time$FEMbasis$mesh$triangles[,3]-1, 
                intensity = rep(0,N),
                color = rep(0,N),
                colors = 'lightgrey',
                opacity = .8,
                hoverinfo = "text",
                text = ~paste("Coordinates: (", round(x,2), round(y,2), ")",
                              "<br>Id: ", id)) %>%
      add_trace(type = 'scatter3d', 
                mode = 'markers',
                x = ~x, y = ~y, z=~z, size = .1, color = I('grey'), opacity = .6,
                hoverinfo = "text",
                text = ~paste("")) %>% 
      hide_colorbar() %>%
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = z.view)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ))) 
    
    
    time_series <- base %>%
      group_by(id) %>%
      add_trace(type = 'scatter', mode = 'lines+markers', x = ~time, y = ~value, hoverinfo = 'text', text = ~paste('Time:', round(time,2), 
                                                                                                                   '<br>Coeff:', round(value,2), 
                                                                                                                   '<br>Id:', id), 
                opacity = .5, line = list(color = 'grey', width = 1), marker = list(color = 'grey', size = 1)) %>% 
      layout(title = "Time evolution of each mesh node", 
             xaxis = list(
               zerolinecolor = '#ffff',
               nticks=10,
               zerolinecolor = '#ffff',
               zerolinewidth = 4,
               gridcolor = 'ffff',
               ticks="inside"),
             
             yaxis = list(
               nticks=10,
               zerolinecolor = '#ffff',
               zerolinewidth = 4,
               gridcolor = 'ffff',
               ticks="inside"))
    
    
    p <- subplot(time_series, spatial, nrows = 2) %>% 
      hide_legend() %>%
      layout(scene = list(domain=list(x=c(0,1),y=c(0,.5)))) %>%
      highlight(on = "plotly_click", off = "plotly_doubleclick", 
                selectize = TRUE, dynamic = TRUE, persistent = TRUE,
                opacityDim = getOption("opacityDim", 0.4), selected = s)
    
    p
  }
  print(p)
}

#' Plot a mesh.2D object
#'
#' @param x A \code{mesh.2D} object defining the triangular mesh, as generated by \code{create.mesh.2D}
#' or \code{refine.mesh.2D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a mesh.2D object, generated by \code{create.mesh.2D} or \code{refine.mesh.2D}.
#' @name plot.mesh.2D

#' @usage \method{plot}{mesh.2D}(x, ...)
#' @export
#' @return No return value
#' @examples
#' library(fdaPDE)
#'
#' ## Upload the quasicirle2D data
#' data(quasicircle2D)
#' boundary_nodes = quasicircle2D$boundary_nodes
#' boundary_segments = quasicircle2D$boundary_segments
#' locations = quasicircle2D$locations
#' data = quasicircle2D$data
#'
#' ## Create mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#'
#' ## Plot the mesh
#' plot(mesh)

plot.mesh.2D<-function(mesh, ...){
  plot_ly(...) %>% 
    add_markers(x = mesh$nodes[,1],
                y = mesh$nodes[,2], 
                color = I('black'),
                hoverinfo = 'text',
                
                text = paste('</br><b> Coordinates:', round(mesh$nodes[,1],2),
                             round(mesh$nodes[,2],2)), 
                showlegend = T, 
                visible = T) %>%
    add_segments(x = mesh$nodes[mesh$edges[,1],1],
                 y = mesh$nodes[mesh$edges[,1],2],
                 xend = mesh$nodes[mesh$edges[,2],1],
                 yend = mesh$nodes[mesh$edges[,2],2], 
                 color = I('black'),
                 showlegend = F) %>%
    add_segments(x = mesh$nodes[mesh$segments[,1],1],
                 y = mesh$nodes[mesh$segments[,1],2],
                 xend = mesh$nodes[mesh$segments[,2],1],
                 yend = mesh$nodes[mesh$segments[,2],2], 
                 color = I('red'),
                 showlegend = F) %>%
    layout(scene = list(
      camera = list(
        eye = list(x = 0, 
                   y = 0, 
                   z = 1.5))), 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ))
}

plot.mesh.map <- function(mesh, provider = providers$CartoDB.Positron, fillColor = 'transparent', 
                          borderColor = 'black', trianglesColor = 'grey', 
                          borderWeight = 2.5, weight = 1.8, ...){
  
  # Creo un multiPolygon per i triangoli 
  polygons <- list()
  for (i in 1:dim(mesh$triangles)[1]) {
    triangle <- mesh$nodes[mesh$triangles[i,],]
    p <- Polygon(triangle)
    polygons[i] = p
  }
  ps <- Polygons(polygons,1)
  sps <- st_as_sf(SpatialPolygons(list(ps)))
  
  # # Creo un polygon per il bordo 
  # poligono <- Polygon(mesh$nodes[c(t(mesh$segments)),])
  # poligono_sp <- Polygons(list(poligono), ID = 1)
  # spsb <- st_as_sf(SpatialPolygons(list(poligono_sp)))
  
  # Display multiPolygon on maps
  map <- leaflet(sps) %>%
    addProviderTiles(provider) %>%
    # add layer with polygons
    addPolygons(
      color = trianglesColor,
      fillColor = fillColor, 
      weight = weight, 
      ...
    ) 
  for (i in 1:nrow(mesh$segments)) {
    map <- map %>%
      addPolylines(lng = mesh$nodes[mesh$segments[i,],1], 
                   lat = mesh$nodes[mesh$segments[i,],2], 
                   color = borderColor, 
                   weight = borderWeight
      )
  }
  map
}

#' Plot a mesh.2.5D object
#'
#' @param x A \code{mesh.2.5D} object generated by \code{create.mesh.2.5D}.
#' @param color Color of the mesh segments.
#' @param width Width of the mesh segments.   
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot the triangulation of a \code{mesh.2.5D} object, generated by \code{create.mesh.2.5D}
#' @export
#' @name plot.mesh.2.5D

#' @usage \method{plot}{mesh.2.5D}(x, ...)
#' @return No return value
#' @examples
#' library(fdaPDE)
#'
#' ## Upload the hub2.5D the data
#' data(hub2.5D)
#' hub2.5D.nodes = hub2.5D$hub2.5D.nodes
#' hub2.5D.triangles = hub2.5D$hub2.5D.triangles
#'
#' ## Create mesh
#' mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)
#' plot(mesh)


plot.mesh.2.5D <- function(mesh, color = 'black', width = 2.5,...){
  
  # Mesh graph
  p <- plot_ly()
  
  for (t in 1:dim(mesh$triangles)[1]) {
    index = c(mesh$triangles[t,],mesh$triangles[t,1])
    p <- p %>%
      add_trace(type = 'scatter3d', 
                mode = 'lines',
                x = mesh$nodes[index,1], 
                y = mesh$nodes[index,2], 
                z = mesh$nodes[index,3], 
                showlegend = F, 
                line = list(width = width, color = color, reverscale = FALSE),
                name = '', ...)
  }
  
  p <- p %>%
    layout(scene = list(
      aspectmode = 'cube', 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )))
  
  # display mesh 
  print(p)
  
}

plot.mesh.2.5D_v2 <- function(mesh, color = 'lightgrey',...){
  
  # Mesh graph
  plot_ly(type = 'mesh3d', 
          x = mesh$nodes[,1], 
          y = mesh$nodes[,2], 
          z = mesh$nodes[,3], 
          i = mesh$triangles[,1]-1,
          j = mesh$triangles[,2]-1,
          k = mesh$triangles[,3]-1,
          facecolor = rep(color, length(mesh$triangles[,1])),
          flatshading = T,  ...) %>%
    layout(scene = list(
      aspectmode = 'cube', 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )))
  
}


#' Plot a mesh.3D object
#'
#' @param x A \code{mesh.3D} object generated by \code{create.mesh.3D}.
#' @param color Color of the mesh faces. 
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a \code{mesh.3D} object, generated by \code{create.mesh.3D}.
#' @export
#' @name plot.mesh.3D
#' @usage \method{plot}{mesh.3D}(x, ...)
#' @return No return value
#' @examples
#' library(fdaPDE)
#'
#' ##Load the matrix nodes and tetrahedrons
#' data(sphere3Ddata)
#'
#' nodes = sphere3Ddata$nodes
#' tetrahedrons = sphere3Ddata$tetrahedrons
#'
#' ##Create the triangulated mesh from the connectivity matrix and nodes locations
#' mesh = create.mesh.3D(nodes,tetrahedrons)
#'
#' ##Plot the triangulation of the object
#' plot(mesh)

plot.mesh.3D <- function(mesh, color = 'white', ...){
  # Check if it is 3D - to do 
  
  # Mesh graph
  plot_ly(type = 'mesh3d', 
          x = mesh$nodes[,1], 
          y = mesh$nodes[,2], 
          z = mesh$nodes[,3], 
          i = mesh$faces[,1]-1,
          j = mesh$faces[,2]-1,
          k = mesh$faces[,3]-1,
          facecolor = rep(color, length(mesh$faces[,1])),
          flatshading = T, 
          lightposition = list(x = 0, y = 0, z = 0), 
          lighting = list(
            ambient = 0, 
            diffuse = 1
          ), ...) %>%
    layout(scene = list(
      aspectmode = 'cube', 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )))
  
}

#' Plot a mesh.1.5D object
#'
#' @param x A \code{mesh.1.5D} object defining the triangular mesh, as generated by \code{create.mesh.1.5D}
#' or \code{refine.mesh.1.5D}.
#' @param ... Arguments representing graphical options to be passed to \link[graphics]{par}.
#' @description Plot a mesh.1.5D object, generated by \code{create.mesh.1.5D} or \code{refine.mesh.1.5D}.
#' @name plot.mesh.1.5D
#' @usage \method{plot}{mesh.1.5D}(x, ...)
#' @return No return value
#' @export

plot.mesh.1.5D<-function(mesh, ...){
  
  if( mesh$order == 1 ){
    plot_ly(...) %>% 
      add_markers(x = mesh$nodes[,1],
                  y = mesh$nodes[,2], 
                  color = I('black'),
                  hoverinfo = 'text',
                  
                  text = paste('</br><b> Coordinates:', round(mesh$nodes[,1],2),
                               round(mesh$nodes[,2],2)), 
                  showlegend = F, 
                  visible = T) %>% 
      add_segments(x = mesh$nodes[mesh$edges[,1],1],
                   y = mesh$nodes[mesh$edges[,1],2],
                   xend = mesh$nodes[mesh$edges[,2],1],
                   yend = mesh$nodes[mesh$edges[,2],2], 
                   color = I('black'),
                   showlegend = F)  %>%
      layout(scene = list(
        camera = list(
          eye = list(x = 0, 
                     y = 0, 
                     z = 1.5))), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ))
    
  }
  else{
    
    plot_ly(...) %>% 
      add_markers(x = mesh$nodes[,1],
                  y = mesh$nodes[,2], 
                  color = I('black'),
                  hoverinfo = 'text',
                  
                  text = paste('</br><b> Coordinates:', round(mesh$nodes[,1],2),
                               round(mesh$nodes[,2],2)), 
                  showlegend = F, 
                  visible = T) %>% 
      add_markers(x = mesh$nodes[mesh$edges[,3],1],
                  y = mesh$nodes[mesh$edges[,3],2], 
                  color = I('red'),
                  hoverinfo = 'text',
                  
                  text = paste('</br><b> Coordinates:', round(mesh$nodes[mesh$edges[,3],1],2),
                               round(mesh$nodes[mesh$edges[,3],2],2)), 
                  showlegend = F, 
                  visible = T) %>%
      add_segments(x = mesh$nodes[mesh$edges[,1],1],
                   y = mesh$nodes[mesh$edges[,1],2],
                   xend = mesh$nodes[mesh$edges[,2],1],
                   yend = mesh$nodes[mesh$edges[,2],2], 
                   color = I('black'),
                   showlegend = F)  %>%
      layout(scene = list(
        camera = list(
          eye = list(x = 0, 
                     y = 0, 
                     z = 1.5))), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ))
  }
}


#' Image Plot of a 2D FEM object
#'
#' @param x A 2D-mesh \code{FEM} object.
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Image plot of a \code{FEM} object, generated by the function \code{FEM} or returned by
#' \code{smooth.FEM} and \code{FPCA.FEM}. Only FEM objects defined over a 2D mesh can be plotted with this method.
#' @usage \method{image}{FEM}(x, num_refinements, ...)
#' @method image FEM
#' @seealso \code{\link{FEM}} \code{\link{plot.FEM}}
#' @export
#' @return No return value
#' @examples
#' library(fdaPDE)
#' ## Upload the horseshoe2D data
#' data(horseshoe2D)
#' boundary_nodes = horseshoe2D$boundary_nodes
#' boundary_segments = horseshoe2D$boundary_segments
#' locations = horseshoe2D$locations
#'
#' ## Create the 2D mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#' ## Create the FEM basis
#' FEMbasis = create.FEM.basis(mesh)
#' ## Compute the coeff vector evaluating the desired function at the mesh nodes
#' ## In this case we consider the fs.test() function introduced by Wood et al. 2008
#' coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2])
#' ## Create the FEM object
#' FEMfunction = FEM(coeff, FEMbasis)
#'
#' ## Plot the FEM function
#' image(FEMfunction)

image.FEM = function(x, num_refinements = NULL, ...)
{
  if(!is(x$FEMbasis$mesh, "mesh.2D"))
    stop('This function is implemented only for 2D mesh FEM objects')
  
  if(x$FEMbasis$order == 1)
  {
    R_image.ORD1.FEM(x, ...)
  }else{
    R_image.ORDN.FEM(x, num_refinements, ...)
  }
}

R_image.ORD1.FEM = function(FEM, ...)
{
  # PLOT  Plots a FEM object FDOBJ over a rectangular grid defined by
  # vectors X and Y;
  
  # How many plots are needed?
  nplots <- ncol(FEM$coeff)
  
  for (i in 1:nplots) {
    
    if (i > 1)
      readline("Press any key for the next plot...")
    
    p <- plot_ly(type = 'mesh3d',
            
            x = FEM$FEMbasis$mesh$nodes[,1],
            y = FEM$FEMbasis$mesh$nodes[,2],
            z = rep(0,dim(FEM$FEMbasis$mesh$nodes)[1]),
            
            i = FEM$FEMbasis$mesh$triangles[,1]-1,
            j = FEM$FEMbasis$mesh$triangles[,2]-1,
            k = FEM$FEMbasis$mesh$triangles[,3]-1, 
            
            intensity = FEM$coeff[,i],
            color = FEM$coeff[,i], 
            hoverinfo = 'text',
            
            text = paste('</br><b> Coordinates:', round(FEM$FEMbasis$mesh$nodes[,1],2),
                         round(FEM$FEMbasis$mesh$nodes[,2],2),
                         
                         '</br><b> Value:', round(FEM$coeff[,i],2)),
            
            ...) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -.01, 
                     z = 2)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom') %>%
      colorbar(len = 1) 
    print(p)
  }
}

R_image.ORDN.FEM = function(FEM, num_refinements, ...)
{
  coeff = FEM$coeff
  
  FEMbasis = FEM$FEMbasis
  
  mesh = FEMbasis$mesh
  
  
  if(is.null(num_refinements))
  {
    num_refinements = 10
  }
  
  x = seq(from = 0, to = 1, length.out = num_refinements+1)
  y = seq(from = 0, to = 1, length.out = num_refinements+1)
  points_ref = expand.grid(x,y)
  points_ref = points_ref[points_ref[,1] + points_ref[,2] <= 1,]
  
  meshi = create.mesh.2D(nodes = points_ref, order = 1)
  #plot(meshi)
  
  locations = matrix(nrow = nrow(mesh$triangles)*nrow(meshi$nodes), ncol = 3*ncol(coeff))
  triangles = matrix(nrow = nrow(mesh$triangles)*nrow(meshi$triangles), ncol = 3*ncol(coeff))
  tot = 0
  
  properties<-R_elementProperties(mesh)
  
  for (i in 1:nrow(mesh$triangles))
  {
    # For each traingle we define a fine mesh as the transofrmation of the one constructed for the reference
    transf<-rbind(cbind(properties$transf_coord$diff1x[i],properties$transf_coord$diff2x[i]),c(properties$transf_coord$diff1y[i],properties$transf_coord$diff2y[i]))
    pointsi = t(transf%*%t(meshi$nodes) + mesh$nodes[mesh$triangles[i,1],])
    #We evaluate the fine mesh OBS: we know the triangle we are working on no need for point location
    z = R_eval_local.FEM(FEM, transf=properties, locations = pointsi, element_index = i)
    
    #We store the results
    locations[((i-1)*nrow(pointsi)+1):(i*nrow(pointsi)),] = cbind(pointsi,z)
    triangles[((i-1)*nrow(meshi$triangles)+1):(i*nrow(meshi$triangles)),] = meshi$triangles+tot
    tot = tot + nrow(meshi$nodes)
  }
  
  nsurf = dim(coeff)[[2]]
  for (i in 1:nsurf) {
    
    if (i > 1)
      readline("Press any key for the next plot...")
    
    p <- plot_ly(type = 'mesh3d',
            
            x = locations[,1],
            y = locations[,2],
            z = rep(0,dim(locations)[1]),
            
            i = triangles[,1]-1,
            j = triangles[,2]-1,
            k = triangles[,3]-1, 
            
            intensity = locations[,2+i],
            color = locations[,2+i],
            hoverinfo = 'text',
            
            text = paste('</br><b> Coordinates:', round(locations[,1],2),
                         round(locations[,2],2),
                         
                         '</br><b> Value:', round(locations[,2+i],2)),
            
            ...) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -.01, 
                     z = 2)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom') %>%
      colorbar(len = 1) 
    print(p)
  }
}


R_image.FEM.time <- function(FEM_time, shared_bar = TRUE, ...)
{
  time <- FEM_time$mesh_time
  time_lenght <- length(FEM_time$mesh_time)
  if(!shared_bar){
    plot_ly(type = 'mesh3d',
            x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
            y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
            z = rep(0, dim(FEM_time$FEMbasis$mesh$nodes)[1]*time_lenght),
            i = FEM_time$FEMbasis$mesh$triangles[,1]-1,
            j = FEM_time$FEMbasis$mesh$triangles[,2]-1,
            k = FEM_time$FEMbasis$mesh$triangles[,3]-1,
            frame = round(sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),2),
            intensity = FEM_time$coeff,
            color = FEM_time$coeff,
            hoverinfo = 'text',
            
            text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                         round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                         
                         '</br><b> Value:', round(FEM_time$coeff,2)),
            ...) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = 2)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom') %>%
      animation_slider(
        currentvalue = list(prefix = "Spatial function in t = ")
        )
      colorbar(len = 1) 
  }
  else{
    plot_ly(type = 'mesh3d',
            x = rep(FEM_time$FEMbasis$mesh$nodes[,1], time_lenght),
            y = rep(FEM_time$FEMbasis$mesh$nodes[,2], time_lenght),
            z = rep(0, dim(FEM_time$FEMbasis$mesh$nodes)[1]*time_lenght),
            i = FEM_time$FEMbasis$mesh$triangles[,1]-1,
            j = FEM_time$FEMbasis$mesh$triangles[,2]-1,
            k = FEM_time$FEMbasis$mesh$triangles[,3]-1,
            frame = round(sort(rep(time, dim(FEM_time$FEMbasis$mesh$nodes)[1])),2),
            intensity = FEM_time$coeff,
            color = FEM_time$coeff,
            hoverinfo = 'text',
            
            text = paste('</br><b> Coordinates:', round(FEM_time$FEMbasis$mesh$nodes[,1],2),
                         round(FEM_time$FEMbasis$mesh$nodes[,2],2),
                         
                         '</br><b> Value:', round(FEM_time$coeff,2)),
            cmin = min(FEM_time$coeff),
            cmax = max(FEM_time$coeff),
            ...) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = 2)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom')  %>%
      animation_slider(
        currentvalue = list(prefix = "Spatial function in t = ")
      ) %>%
      colorbar(len = 1) 
  }
  
}

#' Image plot of a 2D FEM.time object at a given time
#'
#' @param x A 2D-mesh \code{FEM.time} object.
#' @param t time at which do the plot
#' @param lambdaS index of the space penalization parameter to use for the plot, useful when \code{FEM.time} returned by \code{smooth.FEM.time} using GCV
#' @param lambdaT index of the time penalization parameter to use for the plot, useful when \code{FEM.time} returned by \code{smooth.FEM.time} using GCV
#' @param num_refinements A natural number specifying how many bisections should by applied to each triangular element for
#' plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
#' @param ... Arguments representing  graphical options to be passed to \link[rgl]{plot3d}.
#' @description Image plot of a \code{FEM.time} object, generated by the function \code{FEM.time} or returned by
#' \code{smooth.FEM.time}. Only FEM objects defined over a 2D mesh can be plotted with this method.
#' @usage \method{image}{FEM.time}(x,t,lambdaS=1,lambdaT=1,num_refinements=NULL,...)
#' @method image FEM.time
#' @seealso \code{\link{FEM.time}} \code{\link{image.FEM.time}}
#' @return No return value
#' @export
#' @examples
#' library(fdaPDE)
#' ## Upload the horseshoe2D data
#' data(horseshoe2D)
#' boundary_nodes = horseshoe2D$boundary_nodes
#' boundary_segments = horseshoe2D$boundary_segments
#' locations = horseshoe2D$locations
#'
#' ## Create the 2D mesh
#' mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
#' ## Create the FEM basis
#' FEMbasis = create.FEM.basis(mesh)
#' ## Compute the coeff vector evaluating the desired function at the mesh nodes
#' ## In this case we consider the fs.test() function introduced by Wood et al. 2008
#' time = 1:5
#' coeff = rep(fs.test(mesh$nodes[,1], mesh$nodes[,2]),5)*time
#' ## Create the FEM.time object
#' FEM_time_function = FEM.time(coeff=coeff, time_mesh=1:5,FEMbasis=FEMbasis,FLAG_PARABOLIC=TRUE)
#'
#' ## Plot the FEM function
#' t = c(1.2,1.5,3.6,2.4,4.5)
#' image(FEM_time_function,t)
image.FEM.time <- function(x, t, lambdaS=1, lambdaT=1, num_refinements=NULL, shared_bar = TRUE, ...)
{
  t <- as.matrix(t)
  if(!is(x, "FEM.time"))
    stop("x is not of class 'FEM.time'")
  if(is.null(t))
    stop("time required; is NULL")
  if(ncol(t)>1)
    stop("t must be a column vector")
  if(min(t)<x$mesh_time[1] || max(t)>x$mesh_time[length(x$mesh_time)])
    stop("time provided out of the 'time_mesh'")
  if(dim(x$coeff)[2]>1 && lambdaS==1)
    warning("the first value of lambdaS is being used")
  if(dim(x$coeff)[3]>1 && lambdaT==1)
    warning("the first value of lambdaT is being used")
  if(is(x$FEMbasis$mesh, "mesh.2D"))
    N = nrow(x$FEMbasis$mesh$nodes)
  else
    stop("x$FEMbasis$mesh is not of class 'mesh.2D'")
  
  t <- sort(as.vector(t))
  storage.mode(t) <- "double"
  storage.mode(N) <- "integer"
  storage.mode(x$mesh_time) <- "double"
  storage.mode(x$coeff) <- "double"
  storage.mode(x$FLAG_PARABOLIC) <- "integer"
  
  solution <- .Call("eval_FEM_time_nodes",N,x$mesh_time,t,x$coeff[,lambdaS,lambdaT],x$FLAG_PARABOLIC, PACKAGE = "fdaPDE")
  time_lenght <- length(t)
  if(!shared_bar){
    plot_ly(type = 'mesh3d',
            x = rep(x$FEMbasis$mesh$nodes[,1], time_lenght),
            y = rep(x$FEMbasis$mesh$nodes[,2], time_lenght),
            z = rep(0, dim(x$FEMbasis$mesh$nodes)[1]*time_lenght),
            i = x$FEMbasis$mesh$triangles[,1]-1,
            j = x$FEMbasis$mesh$triangles[,2]-1,
            k = x$FEMbasis$mesh$triangles[,3]-1,
            frame = sort(rep(t, dim(x$FEMbasis$mesh$nodes)[1])),
            intensity = solution,
            color = solution,
            hoverinfo = 'text',
            
            text = paste('</br><b> Coordinates:', round(x$FEMbasis$mesh$nodes[,1],2),
                         round(x$FEMbasis$mesh$nodes[,2],2),
                         
                         '</br><b> Value:', round(solution,2)),
            ...) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = 2)), 
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom') %>%
      colorbar(len = 1) %>%
      animation_slider(
        currentvalue = list(prefix = "Spatial function in t = ", font = list(size = 20, 
                                                                             color = 'grey', 
                                                                             family = 'Times New Roman'))
      )
  }
  else{
    plot_ly(type = 'mesh3d',
            x = rep(x$FEMbasis$mesh$nodes[,1], time_lenght),
            y = rep(x$FEMbasis$mesh$nodes[,2], time_lenght),
            z = rep(0, dim(x$FEMbasis$mesh$nodes)[1]*time_lenght),
            i = x$FEMbasis$mesh$triangles[,1]-1,
            j = x$FEMbasis$mesh$triangles[,2]-1,
            k = x$FEMbasis$mesh$triangles[,3]-1,
            frame = sort(rep(t, dim(x$FEMbasis$mesh$nodes)[1])),
            intensity = solution,
            color = solution,
            hoverinfo = 'text',
            
            text = paste('</br><b> Coordinates:', round(x$FEMbasis$mesh$nodes[,1],2),
                         round(x$FEMbasis$mesh$nodes[,2],2),
                         
                         '</br><b> Value:', round(solution,2)),
            cmin = min(solution),
            cmax = max(solution),
            ...) %>% 
      layout(scene = list(
        aspectmode = 'data',
        camera = list(
          eye = list(x = 0, 
                     y = -0.01, 
                     z = 2)),  
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )), 
        dragmode = 'zoom') %>%
      colorbar(len = 1) %>%
      animation_slider(
        currentvalue = list(prefix = "Spatial function in t = ", font = list(size = 20, 
                                                                             color = 'grey', 
                                                                             family = 'Times New Roman'))
      )
  }
  
}

#' Plot data on a mesh domain 
#' @param mesh A \code{mesh.2D} object defining the triangular mesh, as generated by \code{create.mesh.2D}
#' or \code{refine.mesh.2D}.
#' @param locations A 2-column matrix if \code{mesh} is of class \code{mesh.2D}
#' or a 3-column matrix otherwise with the spatial data locations to be plotted. 
#' @param value A 1-column matrix representing the value corresponding to the 
#' \code{locations} provided
#' @param markers.size The size of data points. Default value is 5. 
#' @param ... Arguments representing graphical options of the markers 
#' to be passed to \link[plotly]{add_trace}.
#' @description Domain plot of a \code{mesh} object with markers representing data location and value. 
#' @usage \method{plot}{mesh}(locations, value, markers.size = 5, ...)
#' @method plot mesh
#' @seealso \code{\link{mesh}}
#' @return No return value
#' @export

plot.data <- function(mesh, locations, value, markers.size = 5, ...){
  if(class(mesh) == "mesh.2D")
    R_plot.data.2D(mesh, locations, value, markers.size, ...)
  else if(class(mesh) == "mesh.2.5D")
    R_plot.data.2.5D(mesh, locations, value, markers.size, ...)
  else if(class(mesh) == "mesh.3D")
    R_plot.data.3D(mesh, locations, value, markers.size, ...)
}

R_plot.data.2D <- function(mesh, locations, value, markers.size = 5, ...){
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  if(dim(locations)[1] != dim(value)[1])
    stop("'locations' and 'value' lenghts differ")
  
  plot_ly() %>% 
    add_trace(type = 'mesh3d', 
              name = 'mesh',
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = rep(0, length(mesh$nodes[,1])), 
              i = mesh$triangles[,1]-1, 
              j = mesh$triangles[,2]-1, 
              k = mesh$triangles[,3]-1,
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', 
                           round(mesh$nodes[,1],2),
                           round(mesh$nodes[,2],2)),
              opacity = .8,
              facecolor = rep('lightgrey', length(mesh$triangles[,1]))) %>%
    add_trace(type = 'scatter3d', mode = 'markers', 
              name = 'data',
              x = locations[,1], 
              y = locations[,2], 
              z = rep(0, dim(locations)[1]), 
              color = value, 
              marker = list(size = markers.size), 
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', round(locations[,1],2),
                           round(locations[,2],2),
                           
                           '</br><b> Value:', round(value,2))) %>%
    layout(scene = list(
      aspectmode = 'data',
      camera = list(
        eye = list(x = 0, 
                   y = -.01, 
                   z = 1.5)), 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )),
      dragmode = 'zoom')
}

R_plot.data.2D.time <- function(mesh, locations, value, time, z.view = 2, markers.size = 5, ...){
  
  # convert in matrix form
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  time <- as.matrix(time)
  
  # locations, value and time must have the same number of rows 
  if(nrow(locations) != nrow(value))
    stop("'locations' and 'value' lengths differ.")
  if(nrow(locations) != nrow(time))
    stop("'locations' and 'time' lengths differ.")
  if(nrow(value) != nrow(time))
    stop("'value' and 'time' lengths differ.")
  
  # mesh plot + scatter: domain + data points
  p <- plot_ly() %>%
    add_trace(type = 'mesh3d', 
              opacity = .7,
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = rep(0, length(mesh$nodes[,1])), 
              i = mesh$triangles[,1]-1, 
              j = mesh$triangles[,2]-1,
              k = mesh$triangles[,3]-1,
              facecolor = rep('lightgrey', length(mesh$triangles[,1]))
    ) %>%
    add_trace(
      type = 'scatter3d', mode = 'markers',
      x = locations[,1], 
      y = locations[,2], 
      z = rep(0, nrow(locations)), 
      color = value[,1],
      frame = time[,1], 
      marker = list(size = markers.size, 
                    color = value[,1], 
                    cmin = min(na.omit(value)), 
                    cmax = max(na.omit(value))), 
      ...
    )  %>% 
    layout(scene = list(
      aspectmode = 'data',
      camera = list(
        eye = list(x = 0, 
                   y = -.01, 
                   z = z.view)), 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )), 
      dragmode = 'zoom') %>%
    colorbar(len = 1) 
  
  # display plot 
  print(p)
  
}

plot.data.2D.interactive <- function(mesh, locations, time, value, z.view = 2){
  data <- data.frame(locations, z = 0, time, value)
  names(data) <- c('x', 'y', 'z', 'time', 'value')
  
  locations_unique <- data.frame(unique(cbind(locations)))
  names(locations_unique) <- c('x', 'y')
  locations_unique['id'] = 1:nrow(locations_unique)
  
  df <- merge(data, locations_unique, by = c('x','y'))
  df <- df[order(df$time),]
  
  base <- df %>% 
    highlight_key(~id) %>%
    plot_ly()
  
  spatial <- base %>% 
    group_by(id) %>%
    summarise(x = mean(x), y = mean(y), z = mean(z)*0, id = mean(id)) %>%
    add_trace(type = 'mesh3d', 
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = rep(0,nrow(mesh$nodes)),
              i = mesh$triangles[,1]-1,
              j = mesh$triangles[,2]-1,
              k = mesh$triangles[,3]-1,
              facecolor = rep('lightgrey',nrow(mesh$triangles)),
              hoverinfo = 'none',
              opacity = .8) %>%
    add_trace(type = 'scatter3d', 
              mode = 'markers',
              x = ~x, y = ~y, z=~z, size = 5, color = I('black'), opacity = 1,
              marker = list(size = 3),
              hoverinfo = "text",
              text = ~paste('<br>x:', round(x,2),
                            '<br>y:', round(y,2),
                            '<br>Id:', id)) %>% 
    hide_colorbar() %>%
    layout(scene = list(
      aspectmode = 'data',
      camera = list(
        eye = list(x = 0, 
                   y = -0.01, 
                   z = z.view)), 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ), 
      dragmode = 'zoom')) 
  
  
  time_series <- base %>%
    group_by(id) %>%
    add_trace(type = 'scatter', mode = 'lines+markers', x = ~time, y = ~value, hoverinfo = 'text', text = ~paste('Time:', time, 
                                                                                                                 '<br>Value:', round(value,2), 
                                                                                                                 '<br>Id:', id), 
              opacity = .5, line = list(color = 'grey', width = 1), marker = list(color = 'grey', size = 1)) %>% 
    layout(title = "Time evolution of each data location", 
           xaxis = list(
             zerolinecolor = '#ffff',
             zerolinecolor = '#ffff',
             zerolinewidth = 4,
             gridcolor = 'ffff',
             ticks="inside"),
           
           yaxis = list(
             nticks=10,
             zerolinecolor = '#ffff',
             zerolinewidth = 4,
             gridcolor = 'ffff',
             ticks="inside"))
  
  
  s <- attrs_selected(
    marker = list(opacity = 1, color = 'red', size = 8), 
    line = list(color = 'red', width = 6)
  )
  
  p <- subplot(time_series, spatial, nrows = 2) %>% 
    hide_legend() %>%
    layout(scene = list(domain=list(x=c(0,1),y=c(0,.5)))) %>%
    highlight(on = "plotly_click", off = "plotly_doubleclick", 
              selectize = TRUE, dynamic = TRUE, persistent = TRUE,
              opacityDim = getOption("opacityDim", 0.4), selected = s)
  
  p
  
}

R_plot.data.map <- function(locations, value, opacity = .8, markers.size = 6, provider = 'CartoDB.Positron', palette = 'viridis', ...){
  # convert in matrix form
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  
  # locations, value and time must have the same number of rows 
  if(nrow(locations) != nrow(value))
    stop("'locations' and 'value' lengths differ.")
  
  d <- data.frame(locations, value)
  names(d) <- c('lng', 'lat', 'value')
  
  # create a colormap based on value
  pal <- colorNumeric(palette, c(min(na.omit(value)), max(na.omit(value))), na.color = "white")
  
  # display graph
  leaflet(d) %>%
    addProviderTiles(provider) %>%
    addCircles(
      color = ~pal(value),
      lng = ~lng, lat = ~lat,weight = markers.size, opacity = opacity,
      ...
    ) %>%
    addLegend("topright",
              title = "value", #expression
              pal = pal,
              values = value,
              opacity = opacity,
              labFormat = labelFormat(transform = function(x) sort(x, decreasing = TRUE))) %>%
    addScaleBar(position = c("bottomleft"))
  
  
}

R_plot.data.2.5D <- function(mesh, locations, value, markers.size = 5, ...){
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  if(dim(locations)[1] != dim(value)[1])
    stop("'locations' and 'value' lenghts differ")
  
  p <- plot_ly(showlegend = T) %>% 
    add_trace(type = 'mesh3d', 
              name = 'mesh',
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = mesh$nodes[,3], 
              i = mesh$triangles[,1]-1, 
              j = mesh$triangles[,2]-1, 
              k = mesh$triangles[,3]-1,
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', 
                           round(mesh$nodes[,1],2),
                           round(mesh$nodes[,2],2), 
                           round(mesh$nodes[,3],2)),
              opacity = .8,
              facecolor = rep('lightgrey', length(mesh$triangles[,1]))) %>%
    add_trace(type = 'scatter3d', mode = 'markers', 
              name = 'data',
              x = locations[,1], 
              y = locations[,2], 
              z = locations[,3], 
              color = value, 
              marker = list(size = markers.size), 
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', 
                           round(locations[,1],2),
                           round(locations[,2],2),
                           round(locations[,3],2),
                           
                           '</br><b> Value:', round(value,2)), 
              ...) %>%
    layout(scene = list(
      aspectmode = 'cube',
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )))
  print(p)
}

R_plot.data.2.5D.time <- function(mesh, locations, value, time, markers.size = 5, ...){
  
  # convert in matrix form
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  time <- as.matrix(time)
  
  # locations, value and time must have the same number of rows 
  if(nrow(locations) != nrow(value))
    stop("'locations' and 'value' lengths differ.")
  if(nrow(locations) != nrow(time))
    stop("'locations' and 'time' lengths differ.")
  if(nrow(value) != nrow(time))
    stop("'value' and 'time' lengths differ.")
  
  # mesh plot + scatter: domain + data points
  p <- plot_ly() %>%
    add_trace(type = 'mesh3d', 
              opacity = .7,
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = mesh$nodes[,3], 
              i = mesh$triangles[,1]-1, 
              j = mesh$triangles[,2]-1,
              k = mesh$triangles[,3]-1,
              facecolor = rep('lightgrey', length(mesh$triangles[,1]))
    ) %>%
    add_trace(
      type = 'scatter3d', mode = 'markers',
      x = locations[,1], 
      y = locations[,2], 
      z = locations[,3],
      color = value[,1],
      frame = time[,1], 
      marker = list(size = markers.size, 
                    color = value[,1], 
                    cmin = min(na.omit(value)), 
                    cmax = max(na.omit(value))), 
      ...
    )  %>% 
    layout(scene = list(
      aspectmode = 'cube',
      camera = list(
        xaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        yaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        ),
        zaxis = list(
          title = '',
          showgrid = F,
          zeroline = F,
          showticklabels = F
        )))) %>%
    colorbar(len = 1) %>%
    layout(scene = list(
      aspectmode = 'cube',
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )))
  
  # display plot 
  print(p)
  
}

R_plot.data.3D <- function(mesh, locations, value, markers.size = 5, ...){
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  if(dim(locations)[1] != dim(value)[1])
    stop("'locations' and 'value' lenghts differ")
  
  p <- plot_ly(showlegend = T) %>% 
    add_trace(type = 'mesh3d', 
              name = 'mesh',
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = mesh$nodes[,3], 
              i = mesh$faces[,1]-1, 
              j = mesh$faces[,2]-1, 
              k = mesh$faces[,3]-1,
              flatshading = T, 
              lightposition = list(x = 0, y = 0, z = 0),
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', 
                           round(mesh$nodes[,1],2),
                           round(mesh$nodes[,2],2), 
                           round(mesh$nodes[,3],2)),
              facecolor = rep('lightgrey', length(mesh$faces[,1]))) %>%
    add_trace(type = 'scatter3d', mode = 'markers', 
              name = 'data',
              x = locations[,1], 
              y = locations[,2], 
              z = locations[,3], 
              color = value, 
              marker = list(size = markers.size), 
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', 
                           round(locations[,1],2),
                           round(locations[,2],2),
                           round(locations[,3],2),
                           
                           '</br><b> Value:', round(value,2)), 
              ...) %>%
    layout(scene = list(
      aspectmode = 'cube',
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )))
  print(p)
}
#' per quanto riguarda il 3D ha senso che non si vedano i dati all'interno? non 
#' ha piu senso proiettare i dati su un piano e colorarli in base all'altezza
#' 
R_plot.data.3D.proj <- function(mesh, locations, value, markers.size = 4, ...){
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  if(dim(locations)[1] != dim(value)[1])
    stop("'locations' and 'value' lenghts differ")
  
  # Select options
  s <- attrs_selected(
    marker = list(opacity = 1, size = 8))
  
  data <- data.frame(x = locations[,1], 
                          y = locations[,2], 
                          z = locations[,3],
                          zmin = min(locations[,3])-(max(locations[,3])-min(locations[,3])), 
                          value = value, 
                          id = 1:nrow(locations))%>%
    highlight_key(~id)
  
  p <- plot_ly() %>%
    add_trace(data = data, opacity = 0, x = ~x, y = ~y, z = ~z, color = ~value, type = 'scatter3d', mode = 'markers') %>%
    add_trace(data = data, name = 'projected data', x = ~x, y = ~y, z = ~zmin, color = ~value, type = 'scatter3d', mode = 'markers', 
              marker = list(size = markers.size, color = ~value)) %>%
    add_trace(type = 'mesh3d', 
              name = 'mesh',
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = mesh$nodes[,3], 
              i = mesh$faces[,1]-1, 
              j = mesh$faces[,2]-1,
              k = mesh$faces[,3]-1, 
              flatshading = T,
              opacity = .2, 
              facecolor = rep('lightgrey', length(mesh$faces[,1]))) %>%
    highlight(on = "plotly_click", off = "plotly_doubleclick", 
              opacityDim = getOption("opacityDim", 0.1), selected = s, selectize = T) %>%
    colorbar(len = 1) %>%
    hide_legend() %>%
    layout(dragmode = 'turntable')
  print(p)
}


## Plot dati e smoothing
plot.dati.FEM <- function(FEMs, locations, value, markers.size = 5, ...){
  ## check if FEMs is a list 
  if(class(FEMs) != 'list')
    stop("The parameter 'FEMs' must be of class 'list'")
  
  ## check locations and value dimensions
  locations <- as.matrix(locations)
  value <- as.matrix(value)
  
  if(nrow(locations) != nrow(value))
    stop("'locations' and 'value' lengths differ.")
  
  ## check if in FEMs all elements have the same mesh
  check_mesh <- function(x){
    if(is(x$FEMbasis$mesh, 'mesh.2D'))
      return(TRUE)
    return(FALSE)
  }
  
  if(!all(sapply(FEMs, check_mesh)))
    stop("'FEMs' elements must have the same mesh.")
  
  mesh <- FEMs[[1]]$FEMbasis$mesh
  set_camera <- list(
    eye = list(x = 0, 
               y = -.01, 
               z = 1.5))
  
  p <- plot_ly() %>% 
    add_trace(type = 'mesh3d', 
              name = 'mesh',
              x = mesh$nodes[,1], 
              y = mesh$nodes[,2], 
              z = rep(0, length(mesh$nodes[,1])), 
              i = mesh$triangles[,1]-1, 
              j = mesh$triangles[,2]-1, 
              k = mesh$triangles[,3]-1,
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', 
                           round(mesh$nodes[,1],2),
                           round(mesh$nodes[,2],2)),
              opacity = .8,
              facecolor = rep('lightgrey', length(mesh$triangles[,1]))) %>%
    add_trace(type = 'scatter3d', mode = 'markers', 
              name = 'data',
              x = locations[,1], 
              y = locations[,2], 
              z = rep(0, nrow(locations)), 
              color = value, 
              coloraxis = 'coloraxis',
              marker = list(size = markers.size, coloraxis = 'coloraxis'), 
              hoverinfo = 'text',
              
              text = paste('</br><b> Coordinates:', round(locations[,1],2),
                           round(locations[,2],2),
                           
                           '</br><b> Value:', round(value,2))) %>%
    layout(scene = list(
      aspectmode = 'cube',
      camera = set_camera, 
      xaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      yaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      ),
      zaxis = list(
        title = '',
        showgrid = F,
        zeroline = F,
        showticklabels = F
      )),
      dragmode = 'zoom')
  
  label <- function(x) {
    deparse(substitute(x))
  }
  
  n_funs <- length(FEMs)
  default <- c(rep(T,2),rep(F,n_funs))
  button = list()
  button[[1]] = list(method = "restyle",
                     args = list("visible", as.list(default)),
                     label = 'None')
  
  for(i in 1:n_funs){
    FEM <- FEMs[[i]]
    p <- p %>%
      add_trace(type = 'mesh3d', 
                x = FEM$FEMbasis$mesh$nodes[,1],
                y = FEM$FEMbasis$mesh$nodes[,2],
                z = rep(0, length(FEM$FEMbasis$mesh$nodes[,1])), 
                i = FEM$FEMbasis$mesh$triangles[,1]-1, 
                j = FEM$FEMbasis$mesh$triangles[,2]-1, 
                k = FEM$FEMbasis$mesh$triangles[,3]-1, 
                coloraxis = 'coloraxis', 
                intensity = FEM$coeff, 
                color = FEM$coeff, 
                visible = F, 
                scene = 'scene2'
      )
    
    current = default
    current[2+i] = T
    
    button[[i+1]] = list(method = "restyle",
                         args = list("visible", as.list(current)),
                         label = paste0('FEM',i))
  }
  p <- p %>%
    layout(
      updatemenus = list(
        list(buttons = button)), 
      scene = list(domain=list(x=c(0,0.5),y=c(0,1)),
                   camera = set_camera),
      scene2 = list(domain=list(x=c(0.5,1),y=c(0,1)), 
                    camera = set_camera, 
                    xaxis = list(
                      title = '',
                      showgrid = F,
                      zeroline = F,
                      showticklabels = F
                    ),
                    yaxis = list(
                      title = '',
                      showgrid = F,
                      zeroline = F,
                      showticklabels = F
                    ),
                    zaxis = list(
                      title = '',
                      showgrid = F,
                      zeroline = F,
                      showticklabels = F
                    )),
      coloraxis=list(colorscale='YlOrRd', 
                     cmin = min(value),
                     cmax = max(value))) %>%
    hide_legend()
  
  # display figure
  print(p)
  
}

R_eval_local.FEM = function(FEM, transf, locations, element_index)
{
  N = nrow(locations)
  # Augment Xvec and Yvec by ones for computing barycentric coordinates
  Pgpts = cbind(matrix(1,N,1),locations[,1],locations[,2])
  
  # Get nodes and index
  FEMbasis = FEM$FEMbasis
  mesh = FEMbasis$mesh
  nodes = mesh$nodes
  triangles = mesh$triangles
  coeff = FEM$coeff
  nsurf = dim(coeff)[2]
  
  order = FEMbasis$order
  #nodeindex = params$nodeindex
  detJ = transf$detJ
  
  # 1st, 2nd, 3rd vertices of triangles
  
  v1 = nodes[triangles[element_index,1],]
  v2 = nodes[triangles[element_index,2],]
  v3 = nodes[triangles[element_index,3],]
  
  if(order !=2 && order != 1)
  {
    stop('ORDER is neither 1 or 2.')
  }
  
  # Denominator of change of coordinates chsange matrix
  
  modJ = transf$detJ[element_index]
  ones3 = matrix(1,3,1)
  #modJMat = modJ %*% t(ones3)
  
  M1 = c(v2[1]*v3[2] - v3[1]*v2[2], v2[2] - v3[2], v3[1] - v2[1])/(modJ)
  M2 = c(v3[1]*v1[2] - v1[1]*v3[2], v3[2] - v1[2], v1[1] - v3[1])/(modJ)
  M3 = c(v1[1]*v2[2] - v2[1]*v1[2], v1[2] - v2[2], v2[1] - v1[1])/(modJ)
  
  evalmat = matrix(NA, nrow=N, ncol=nsurf)
  
  for (isurf in 1:nsurf)
  {
    for(i in 1:N)
    {
      baryc1 = (M1*Pgpts[i,]) %*% ones3
      baryc2 = (M2*Pgpts[i,]) %*% ones3
      baryc3 = (M3*Pgpts[i,]) %*% ones3
      
      if(order == 2)
      {
        c1 = coeff[triangles[element_index,1],isurf]
        c2 = coeff[triangles[element_index,2],isurf]
        c3 = coeff[triangles[element_index,3],isurf]
        c4 = coeff[triangles[element_index,6],isurf]
        c5 = coeff[triangles[element_index,4],isurf]
        c6 = coeff[triangles[element_index,5],isurf]
        
        fval =  c1*(2* baryc1^2 - baryc1) +
          c2*(2* baryc2^2 - baryc2) +
          c3*(2* baryc3^2 - baryc3) +
          c4*(4* baryc1 * baryc2) +
          c5*(4* baryc2 * baryc3) +
          c6*(4* baryc3 * baryc1)
        evalmat[i,isurf] = fval
      }else{
        c1 = coeff[triangles[element_index,1],isurf]
        c2 = coeff[triangles[element_index,2],isurf]
        c3 = coeff[triangles[element_index,3],isurf]
        fval = c1*baryc1 + c2*baryc2 + c3*baryc3
        evalmat[i,isurf] = fval
      }
    }
  }
  return(evalmat)
}

R_elementProperties=function(mesh)
{
  nele = dim(mesh$triangles)[[1]]
  nodes = mesh$nodes
  triangles = mesh$triangles
  
  #detJ   = matrix(0,nele,1)      #  vector of determinant of transformations
  #metric = array(0,c(nele,2,2))  #  3-d array of metric matrices
  #transf = array(0,c(nele,2,2))
  
  transf_coord = NULL
  transf_coord$diff1x = nodes[triangles[,2],1] - nodes[triangles[,1],1]
  transf_coord$diff1y = nodes[triangles[,2],2] - nodes[triangles[,1],2]
  transf_coord$diff2x = nodes[triangles[,3],1] - nodes[triangles[,1],1]
  transf_coord$diff2y = nodes[triangles[,3],2] - nodes[triangles[,1],2]
  
  #  Jacobian or double of the area of triangle
  detJ = transf_coord$diff1x*transf_coord$diff2y - transf_coord$diff2x*transf_coord$diff1y
  
  #Too slow, computed only for stiff from diff1x,diff1y,..
  # for (i in 1:nele)
  # {
  #   #transf[i,,] = rbind(cbind(diff1x,diff2x),c(diff1y,diff2y))
  #   #  Compute controvariant transformation matrix OSS: This is (tranf)^(-T)
  #   Ael = matrix(c(diff2y, -diff1y, -diff2x,  diff1x),nrow=2,ncol=2,byrow=T)/detJ[i]
  #
  #   #  Compute metric matrix
  #   metric[i,,] = t(Ael)%*%Ael
  # }
  
  #FEStruct <- list(detJ=detJ, metric=metric, transf=transf)
  FEStruct <- list(detJ=detJ, transf_coord=transf_coord)
  return(FEStruct)
}
